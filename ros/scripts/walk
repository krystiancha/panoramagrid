#!/usr/bin/env python2
from argparse import ArgumentParser
from math import pi

import numpy as np
from geometry_msgs.msg import Vector3, Transform, TransformStamped, Quaternion
from rospy import init_node, Rate, is_shutdown
from std_msgs.msg import Header
from tf.transformations import quaternion_from_euler
from tf2_ros import TransformBroadcaster


class Walk:
    def __init__(self, start_point, radius, rate=30, speed=1):
        init_node("walk")
        self.broadcaster = TransformBroadcaster()
        self.r = Rate(rate)

        self.start_point = start_point
        self.radius = radius
        self.rate = rate
        self.speed = speed

    def circle_point(self):
        for displacement in self.gen_points(0, self.radius):
            self._apply(displacement, 0)

        for angle in self.gen_points(0, 2 * pi, angle=True):
            x = self.radius * np.cos(angle)
            y = self.radius * np.sin(angle)
            self._apply(x, y, 0, np.arctan2(0 - y, 1 - x))

        for rotation in self.gen_points(0, pi, angle=True):
            self._apply(self.radius, 0, 0, rotation)

        for displacement in self.gen_points(self.radius, 0):
            self._apply(displacement, 0, 0, pi)

        for rotation in self.gen_points(pi, 0, angle=True):
            angle = rotation
            self._apply(0, 0, 0, angle)

    def merry(self):
        for displacement in self.gen_points(0, self.radius):
            self._apply(displacement, 0)

        for rotation in self.gen_points(0, pi, angle=True):
            angle = rotation
            self._apply(self.radius, 0, 0, angle)

        for angle in np.linspace(0, 2 * pi, 2 * pi * self.rate):
            self._apply(self.radius * np.cos(angle), self.radius * np.sin(angle), 0, angle + pi)

        for displacement in np.linspace(self.radius, 0, self.rate):
            self._apply(displacement, 0, 0, pi)

        for rotation in np.linspace(pi, 0, 2 * self.rate):
            angle = rotation
            self._apply(0, 0, 0, angle)

    def square(self):
        x, y = (0, 0)
        angle = 0

        for displacement in np.linspace(0, self.radius, self.rate / self.speed):
            x = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(0, pi / 2, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(0, self.radius, self.rate / self.speed):
            y = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(pi / 2, pi, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(self.radius, -self.radius, 2 * self.rate / self.speed):
            x = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(pi, 3 * pi / 2, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(self.radius, -self.radius, 2 * self.rate / self.speed):
            y = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(3 * pi / 2, 2 * pi, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(-self.radius, self.radius, 2 * self.rate / self.speed):
            x = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(2 * pi, 5 * pi / 2, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(-self.radius, 0, self.rate / self.speed):
            y = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(5 * pi / 2, 3 * pi, self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        for displacement in np.linspace(self.radius, 0, self.rate / self.speed):
            x = displacement
            self._apply(x, y, 0, angle)

        for rotation in np.linspace(3 * pi, 4 * pi, 2 * self.rate / self.speed):
            angle = rotation
            self._apply(x, y, 0, angle)

        return True

    def num_distance(self, distance):
        return self.rate * distance / self.speed

    def num_angle(self, angle):
        return self.num_distance(self.radius * angle / 2 * pi)
    
    def gen_points(self, start, end, angle=False):
        if angle:
            return np.linspace(start, end, self.num_angle(abs(end - start)))
        
        return np.linspace(start, end, self.num_distance(abs(end - start)))

    def _apply(self, x, y, z=0.0, angle=0.0):
        if is_shutdown():
            return False

        quat = quaternion_from_euler(0, 0, angle)
        x0, y0, z0 = self.start_point

        self.broadcaster.sendTransform(
            TransformStamped(
                header=Header(frame_id="world"),
                child_frame_id='camera',
                transform=Transform(
                    translation=Vector3(x=(x0 + x), y=(y0 + y), z=(z0 + z)),
                    rotation=Quaternion(*quat),
                ),
            ),
        )
        self.r.sleep()


if __name__ == '__main__':
    walk = Walk(start_point=(0.5, -0.5, 1), radius=0.5)

    parser = ArgumentParser()
    parser.add_argument('-1', '--once', action='store_true')
    parser.add_argument('-s', '--speed', type=float, default=1.0)
    subparsers = parser.add_subparsers()

    spiral = subparsers.add_parser('square')
    spiral.set_defaults(func=walk.square)

    spiral = subparsers.add_parser('merry')
    spiral.set_defaults(func=walk.merry)

    spiral = subparsers.add_parser('circle_point')
    spiral.set_defaults(func=walk.circle_point)

    args = parser.parse_args()

    walk.speed = args.speed

    while True:
        if not args.func() or args.once:
            break
